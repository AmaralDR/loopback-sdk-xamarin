<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ output extension=".cs"#>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ assembly name="Microsoft.CSharp" #>
<#@ import namespace="Microsoft.CSharp" #>
<# /* Uncomment the following line when debugging */ #>
<#/*@assembly name="C:/Users/PerfectedTech/Documents/Repositories/lbxamarinsdk-generator/SDKGeneratorDLL/LBXamarinSDK/bin/Debug/Newtonsoft.Json.dll"*/#>
<# /* ^^ */ #>
<#@ import namespace="Newtonsoft.Json" #>
<#@ import namespace="Newtonsoft.Json.Linq" #>
<#@ parameter name="jsonModel" type="System.String" #>
/**
 *** Dynamic Models ***
 */
<#

// Uncomment the following line when debugging:
//string jsonModel = File.ReadAllText("D:/debug.txt");
// ^^
#>

namespace LBXamarinSDK
{
<#
// Iterate over all the models to create a class for them
JObject modelsJSON = JObject.Parse(jsonModel);
List<String> modelNames = modelsJSON.First.First.Select(x => (string)x.First).ToList();
foreach (var model in modelsJSON.First.First)
{
	// Determine model name and inheritence, avoid self inheritence
	String modelName = model.First.First.ToString();
	String inheritenceString = (String)model.ElementAt(2).First == "" || (String)model.ElementAt(2).First == "PersistedModel" ? "Model" : (String)model.ElementAt(2).First;
	if(inheritenceString == modelName || !modelNames.Contains(inheritenceString))
	{
		inheritenceString = "Model";
	}
#>
	public partial class <#= modelName #> : <#= inheritenceString#>
	{
<#		
		// Determine the ID field, gather information about the fields of the model
		String IDField = "";
		JObject fieldsObj = JObject.Parse(model.ElementAt(4).First.ToString());
        List<string> fields = fieldsObj.Properties().Select(p => p.Name).ToList();
		List<bool> fieldIsArrayList = new List<bool>();
        List<string> fieldsNecessities = new List<string>();
        List<string> fieldsTypes = new List<string>();
		foreach (var fieldProperties in model.ElementAt(4).First)
        {
			fieldsNecessities.Add((String)fieldProperties.First.First.Next.First);
			fieldsTypes.Add((String)fieldProperties.First.First.First);
			fieldIsArrayList.Add((bool)fieldProperties.First.ElementAt(3).First);
			if ((bool)fieldProperties.First.ElementAt(2).First)
            {
				JObject tempObj = JObject.Parse("{" + fieldProperties.ToString() + "}");
				IDField = (String)tempObj.Properties().Select(p => p.Name).First();
			}
		}
		string idType = "string";

		// Add all fields, with Json tags
        for (int i = 0; i < fields.Count; ++i)
        {
			string fieldAccessTag;
			string fieldType;
			string fieldName;
			// Do we need a nullable interface for the field or not?
			if(isPrimitiveType(jsTypeToCsType(fieldsTypes.ElementAt(i))) && !fieldIsArrayList.ElementAt(i) && fields.ElementAt(i) != IDField)
            {
				/* This is a primitive type which needs to be exposed to the serializer as nullable, but to the user as true primitive.
				*  Therefore we add a private nullable field and an true primitive interface field for the user.
				*/
				fieldAccessTag = "private";
				fieldType = nullablify(jsTypeToCsType(fieldsTypes.ElementAt(i)));
				fieldName = createNullableName(createLegalVariable(fields.ElementAt(i)));

				// Add an interface:
#>		[JsonIgnore]
		public <#=jsTypeToCsType(fieldsTypes.ElementAt(i))#> <#= createLegalVariable(fields.ElementAt(i)) #>
		{
			get { return <#=createNullableName(createLegalVariable(fields.ElementAt(i)))#> ?? new <#= jsTypeToCsType(fieldsTypes.ElementAt(i)) #>(); }
			set { <#="_" + createLegalVariable(fields.ElementAt(i))#> = value; }
		}
<#
            }
			else // This is not a primitive type field, no special interface needed.
            {
				fieldAccessTag = "public";
				fieldType = jsTypeToCsType(fieldsTypes.ElementAt(i));
				fieldName = createLegalVariable(fields.ElementAt(i));
			}

			// Add the field itself:
			#>		[JsonProperty ("<#=fields.ElementAt(i)#>", NullValueHandling = NullValueHandling.Ignore)]
		<#= fieldAccessTag #> <#=fields.ElementAt(i) == IDField ? idType : fieldType#><#if(fieldIsArrayList.ElementAt(i)){#>[]<#}#> <#=fieldName#> { get; set; }

<#
		
		}#>		
		// This method identifies the ID field
		public override string getID()
		{
			return <# if((bool)model.ElementAt(3).First == true) {#>id<#}else{#><##><#=IDField#><#}#>;
		}
	}
<#}#>

	// Relationship classes:
<#
// Create classes for responses and input of relationship type "hasAndBelongsToMany" 
List<string> existentRelationshipResponses = new List<string>();
foreach (var model in modelsJSON.First.First)
{
	foreach(var rel in model.ElementAt(6).First) {

		if(rel != null && (string)rel.First.ElementAt(2).First == "hasAndBelongsToMany") {
			string responseClassName = (string)model.First.First + (string)rel.First.ElementAt(1);
			if(!existentRelationshipResponses.Contains(responseClassName)) {
				existentRelationshipResponses.Add(responseClassName);

				string firstFieldName = decapitalize((string)model.First.First) + "Id";
				string secondFieldName = decapitalize((string)rel.First.ElementAt(1)) + "Id";
#>
	public class <#= responseClassName #> : Model
	{
		[Newtonsoft.Json.JsonProperty("id")]
        public string id { get; set; }

		[Newtonsoft.Json.JsonProperty("<#= firstFieldName #>")]
        public string <#= firstFieldName #> { get; set; }

		[Newtonsoft.Json.JsonProperty("<#= secondFieldName #>")]
        public string <#= secondFieldName #> { get; set; }
	}

<#
            }
        }
    }
}

if(existentRelationshipResponses.Count == 0) {#>	// None.
<#}
#>}
// Eof
<#+

// Creates a valid field name: Avoid keywords, don't begin with numeric, etc
private string createLegalVariable(string input)
{
	string result = input;
	CSharpCodeProvider cs = new CSharpCodeProvider();
	if(!cs.IsValidIdentifier(result))
    {
		result = "field_" + result;
    }
	return result;
}

// Decapitalizes a string
public static string decapitalize(string input)
{
	if(string.IsNullOrEmpty(input))
		return input;
	return input.ElementAt(0).ToString().ToLower() + input.Substring(1);
}

// Creates a nullable typename out of a typename
public string nullablify(string strType)
{
	return strType + "?";
}

// Creates a private member variable name by adding an underscore to the name
public string createNullableName(string strName)
{
	return "_" + strName;
}

// Checks if the given type is primitive
public bool isPrimitiveType(string strType)
{
	if(strType == "double" || strType == "DateTime" || strType == "bool")
		return true;
	return false;
}

// Converts a loopback type name to c# type name. E.g. Number to double
public String jsTypeToCsType(String JSType)
{
	if(JSType == "Number")
		return "double";

	if(JSType == "GeoPoint")
		return "GeoPoint";

	if(JSType == "Buffer")
		return "IList<int>";

	if(JSType == "String")
		return "String";

	if(JSType == "Boolean")
		return "bool";

	if(JSType == "Date")
		return "DateTime";

	if(JSType == "ObjectID")
		return "String";

	return "Object";
}#>
